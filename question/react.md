## React部分

1. 如何在React中处理表单输入？
	- A：使用React的受控组件来处理表单输入。通过将表单元素的值绑定到组件的状态变量上，并在`onChange`事件中更新状态，可以实现实时更新表单输入的效果。
	- 解析：将表单元素的值绑定到组件的状态来实现受控组件。通过`<input>`元素上设置`value`属性为组件的状态，在`onChange`事件中更新状态，以达到实时更新表单输入的效果
2. 如何在React中进行组件间通信？
	- A：通过state和props来实现react组件间的通信。通过将数据作为props传递给子组件，或者通过改变state来触发组件的重新渲染，以达到组件间通信
3. 如何在React中处理组件的生命周期？
	- A：可以使用React的生命周期方法来处理组件的生命周期，如`componentDidMount`方法会在组件挂载后调用，`componentWillUnmount`方法会在组件卸载前调用。
	- 解析：React组件的生命周期包括挂载、更新和卸载三个阶段。通过在组件中定义生命周期方法，可以在不同的阶段执行相应的操作
4. 请解释一下React中的虚拟DOM。
	- A：虚拟DOM是React中的一种概念，它是用JavaScript对象来表示真实DOM的一种抽象（React通过虚拟DOM将React元素和真实DOM进行映射）。在React中，当数据发生变化时，React会通过比较虚拟DOM和真实DOM的差异，然后只更新需要更新的部分，从而提高性能。
5. 请解释一下React中的状态（state）和属性（props）。
	- A：React中的状态是组件内部的数据，状态是可以改变的，当状态发生变化时，React会自动重新渲染组件。`react`具有单向数据流的特性，所以属性通常是从父组件传递给子组件的的数据，属性只能由父组件修改。
6. 说说对React的理解？有哪些特性？
	- A：React就是用来构建用户界面的JavaScript库，循序组件设计模式、声明式编程和函数式编程，使前端应用程序更高效，使用虚拟DOM来操作DOM，遵循高阶组件到低阶组件的单向流数据。
		React具有很多特性，如`JSX语法`、`单向数据绑定`、`虚拟DOM`、`声明式编程`、`组件化开发`
7. 请描述你对纯函数的理解？
	- A：固定的输入，有固定的输出，且不包含任何副作用的函数称之为纯函数。纯函数不会更改函数调用前就存在的变量或对象。
8. React的严格模式有什么用处？
	- A：在React中严格模式仅在开发环境中生效，严格模式用 `<React.StrictMode>`标签来包裹想要检查的组件，严格模式会调用每个组件两次，可以用于帮助我们：
		- 识别不安全的生命周期
		- 使用过时的API时发出警告
		- 检测存在副作用的组件
		- 检测不安全的使用方式（如使用废弃的context API）
	
		综上严格模式可以帮只我们更早发现潜在问题。
9. React中的key有什么作用？
	- A：在React的列表渲染中每一个子元素都应该需要一个唯一的key值（通常我们使用id来作为key），用来标识唯一元素 
		> 元素`key`属性的作用是用于判断元素是新创建的还是被移动的元素（当设置key属性后，元素再进行比较时，就不会按照顺序比较，而是按照相同key属性值进行比较），从而减少不必要的修改
		>
		> 如果只是文本内容改变了，不写`key`反而性能和效率更高，但如果涉及到节点的删除和新增，则key可以增加性能的开销	
10. 说说对受控组件和非受控组件的理解？应用场景？
	- A：对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state，这一原则成为可信单一数据源
		- 受控组件简单来说就是受我们控制的组件，当组件中的重要信息是由 props 而不是其自身状态驱动时，就可以认为该组件是受控组件，其行为完全由父组件指定。以一个输入框为例，若想要输入框中内容随着用户输入而变化，通常需要一个初始状态和状态更新函数才能实现受控输入框
	
		- 非受控组件，通常把包含不受控制状态的组件称为非受控组件，简单来讲，就是不受我们控制的组件。一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态。当需要时，可以使用`ref` 查询 `DOM `并查找其当前值
	
		- 应用场景如下
	
			|         特征         | 非受控 | 受控 |
			| :------------------: | :----: | :--: |
			| 一次性取值（提交时） |   √    |  √   |
			|      提交时验证      |   √    |  √   |
			|     即时现场验证     |   ×    |  √   |
			| 有条件地禁用提交按钮 |   ×    |  √   |
			|     强制输入格式     |   ×    |  √   |
			|  一个数据的多个输入  |   ×    |  √   |
			|       动态输入       |   ×    |  √   |
11. 说说对React中类组件和函数组件的理解？有什么区别？
	- A：
		- 类组件：就是使用ES6中类的形式去编写组件，该类必须继承`React.Component`，在组件中必须实现`render()`方法，在return中返回React对象，通过`this.props`访问父组件传递的参数
		- 函数组件：通过函数形式去实现React组件，函数参数作为props接收父组件传递的参数
		区别分为如下几个方面：

		> （1）编写形式
		>
		> （2）状态管理：在hooks出来之前，函数组件是无状态组件，不能保存组件的状态
		>
		> （3）生命周期：在函数组件中，并不存在生命周期，因为声明周期的方法继承`React.Component`，但函数组件中可以使用`useEffet`来达到替代生命周期的作用
		>
		> （4）调用方式：函数组件直接调用即可，类组件需要进行实例化，然后调用实例对象的render方法
		>
		> （5）获取渲染的值：类组件中this使用过多
12. 说说react中引入css的方式有哪几种？区别？
	- A：方式有如下几种

		- 在组件内通过style属性设置

			> 优点：内联样式不会有冲突、可以动态设置样式
			>
			> 缺点：大量样式造成代码混乱、某些样式无法编写

		- 组件中引入.css文件

			> 符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠和冲突

		- 组件中引入 .moudle.css文件

			> 优点：只针对当前模块生效，不会发生冲突
			>
			> 缺点：不方便动态修改样式，需要使用内联的方式进行样式的编写

		- CSS in JS 是一种模式，CSS由JS生成不用通过外部文件定义有第三方库提供（styled-components、emotion）

			> 满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态
13. 说说React中JSX语法
	- A：JSX既不是字符串，也不是HTML，而是一种类似XML，用于描述用户界面的JavaScript扩展语法，可以用于创建React元素。JSX为视图和数据架起了一座沟通的桥梁，JSX最终会被编译成普通的JavaScript对象，所以能够直接使用JavaScript语法，因此我们可以在JS中编写JSX。
	
		> 在JSX的任意位置都能插入表达式，但必须用花括号包裹住才能有效。
		>
		> JSX中会自动将数组中元素在页面中显示
		>
		> 可以直接为标签设置属性
	
		编写JSX需要遵循以下规则：
		
		- 必须用一个跟元素包裹其它元素或文本（因为JSX在底层被转化为了JS对象，一个函数中不能返回多个对象）
		- 所有的元素还必须得闭合
14. 说说 React中的setState执行机制
	- A：
		> 一个组件显示什么内容是由数据状态和外部参数所决定，而数据状态就是`state`，若想更新组件内部的数据，则需要通过setState来修改state的值。如果直接修改state的值，会发现页面不会发生任何变化（此时state已经被我们修改了），因为React中必须通过`setState`方法来告知`react`组件`state`已经发生了改变。setState的第一个参数可以是一个对象或函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据
	
		> 在使用setState更新数据时，setState的更新分为同步更新和异步更新
		>
		> - 在组件生命周期或React合成事件中，setState是异步
		> - 在setTimeout或者原生dom事件中，setState是同步
15. 说说 Real DOM和 Virtual DOM 的区别？优缺点？
	- A：
		区别如下：
	
		> - 虚拟DOM不会进行排版与重绘操作，而真实DOM会频繁重排与重绘
		> - 虚拟DOM的总损耗是“虚拟DOM增删改+真实DOM差异增删改+排版与重绘”，真实DOM的总损耗是“真实DOM完全增删改+排版与重绘”
		>
		> 当你在一次操作时，若需要更新10个`DOM`节点，浏览器收到第一个更新`DOM`请求后，并不知道后续还有9次更新操作，最终执行10次流程
		>
		> 而虚拟节点不会立即操作DOM，而是将这10次更新的`diff`内容保存到本地的一个`js`对象中，最终将这个`js`对象一次性`attach`到`DOM`树上，避免大量的无谓计算
	
		优缺点：
	
		> 真实DOM：
		>
		> - 优点：易用，针对低频次、低复杂度的DOM操作时性能较好
		> - 缺点：
		> 	1. 效率低，解析速度慢，内存占用量过高
		> 	2. 性能差：频繁操作真实DOM，易于导致重绘与回流
		>
		> 虚拟DOM：
		>
		> - 优点：
		> 	1. 简单方便
		> 	2. 提高性能：在复杂场景下，能够有效避免对真实DOM频繁操作，减少多次引起重绘与回流，提高性能
		> - 缺点：首次渲染速度慢、无法针对性的作出优化
	
		解析：
	
		- Real DOM：真实DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实`DOM`结构
		- Virtual DOM：本质上是以 `JavaScript` 对象形式存在的对 `DOM` 的描述，创建虚拟`DOM`目的就是为了更好将虚拟的节点渲染到页面视图中，与真实DOM进行映射。React中的虚拟DOM就是通过将JSX转化为JS对象来实现的
16. React中组件之间的通信方式？
	- A：根据传送者和接受者可以将通信方式分为以下几种：
		> - 父组件向子组件传递：React的数据流动是单向的，父组件通过 props 向子组件传递需要的信息
		> - 子组件向父组件传递：本质也是通过props实现，需要父组件传递一个函数作为props，通过回调函数将信息发送给父组件
		> - 祖先组件向后代组件传递：使用context，context相当于一个大容器，我们可以把要通信的内容放在这个容器中，对于跨越多层的全局数据可以使用context实现
		> - 非嵌套关系组件传递：将数据进行一个全局资源管理，从而实现通信，例如`redux`。若是兄弟节点，可以找到其共同父组件
17. 说说你对声明式编程的理解？
	- A：声明式编程就是以结果为导向的编程，区别于命令式不用我们一步一步的告诉计算机要做什么，最后产生什么结果，声明式只需告诉计算机要什么结果，不关心过程。
18. react的状态提升是什么？使用场景有哪些？
	- A：
		- 概念：当多个组件需要公用一些状态时，把共有的状态提取到父组件中并通过props将数据或信息传递到子组件，这就是状态提升，这样统一了数据来源，使逻辑更加清晰。
		- 使用场景：子组件的数据相互耦合，相互依赖，可能还存在相互修改的情况下使用。
19. 说说React的事件机制？
	- A：
		- 在React中的事件机制被称之为合成事件（循序W3C规范来定义合成事件，兼容所有浏览器），合成事件是 `React `模拟原生 `DOM `事件所有能力的一个事件对象，基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等，如：
			```jsx
			//e.nativeEvent可以获取原生DOM事件，e代表事件对象
			const handleClick = (e) => console.log(e.nativeEvent);;
			const button = <button onClick={handleClick}>按钮</button>
			```

			> 虽然onClick看似绑定到了DOM上但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听。
			>
			> 这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象
			>
			> 当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升

		- 关于执行顺序：React 所有事件都挂载在 document 对象上，而不是 React 组件对应的 DOM

			1. 当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件
			2. 所以会先执行原生事件，然后处理 React 事件
			3. 最后真正执行 document 上挂载的事件
20. 为什么说React中的props是只读的？
	- A：这样保证react的单向数据流的设计模式，使状态更可预测。如果允许组件修改，那么一个父组件将状态传递给好几个子组件，这几个子组件随意修改，就完全不可预测，不知道在什么地方修改了状态。为了保证组件像纯函数一样没有响应的副作用，所以我们必须像纯函数一样保护 props 不被修改。
21. React事件绑定的方式有哪些？区别？
	- A：在react中，事件名都是用小驼峰格式进行书写，且事件的绑定使用`{}`包裹，其绑定方法如下（类组件中）：

		- render方法中使用bind，在其中给某个组件/元素一个`onClick`属性，它并不会自定绑定其`this`到当前组件，可以通过在事件函数后使用`.bind(this)`将`this`绑定到当前组件中

			```jsx
			class App extends React.Component{
			    handleClick() {
			    console.log('this > ', this);
			  }
			  render() {
			    return (
			      <div onClick={this.handleClick.bind(this)}>test</div>
			    )
			  }
			}
			```

			该绑定方式在组件每次render渲染时，都会重新进行this的绑定，影响性能

		- render方法中使用箭头函数，通过ES6的上下文来将`this`的指向绑定给当前组件，同样每一次render的时候都会生成新的方法，影响性能

			```jsx
			class App extends React.Component{
			    handleClick() {
			    console.log('this > ', this);
			  }
			  render() {
			    return (
			      <div onClick={e=>this.handleClick(e)}>test</div>
			    )
			  }
			}
			```

		- constructor中bind，可以避免在`render`操作中重复绑定

			```jsx
			class App extends React.Component{
			   constructor(props) {
			    super(props);
			    this.handleClick = this.handleClick.bind(this);
			  }
			   handleClick() {
			    console.log('this > ', this);
			  }
			  render() {
			    return (
			      <div onClick={this.handleClick}>test</div>
			    )
			  }
			}
			```

		- 定义阶段使用箭头函数绑定，同样可以避免中重复绑定，实现也非常的简单

			```jsx
			class App extends React.Component{
			   handleClick= () => {
			    console.log('this > ', this);
			  }
			  render() {
			    return (
			      <div onClick={this.handleClick}>test</div>
			    )
			  }
			}
			```

		区别：

		> 编写方面：方式一、方式二写法简单，方式三的编写过于冗杂
		>
		> 
		>
		> 性能方面：方式一和方式二在每次组件render的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例，四是最优解
22. 描述下在react中无状态组件和有状态组件的区别是什么？
	- A：状态即是state，在hooks出现之前函数组件都是无状态组件
		- 无状态组件：无状态组件主要用于内容展示，接收来自父组件props传递过来的数据，使用props来展示父组件传递的内容。无状态组件应该保持模板的纯粹性，以便于组件复用。
		- 状态组件：状态组件主要用来定义交互逻辑和业务数据，有自己的state，需要处理副作用等反馈到state状态上。
