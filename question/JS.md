## JS部分

1. 如何判断一个变量是否为数组？
	- A：可以使用`Array.isArray()`方法来判断一个变量是否为数组。例如：`Array.isArray(myArray)`。
	- 解析：`Array.isArray()`是一个静态方法用于判断一个变量是否为数组。它返回一个布尔值，如果变量是数组则返回`true`，否则返回`false`。
2. 如何获取当前日期和时间？
	- A：可以使用`Date`对象来获取当前日期和时间
	- 解析：`Date`对象是JS的内置对象用于处理日期和时间。通过创建一个`Date`对象，可以获取当前日期和时间
3. 说几条写 JavaScript 的基本规范？
	- A：
	
		> 1. 一个函数作用域中所有的变量声明应该尽量提到函数首部。声明时如果变量没有值，应该给该变量赋值对应类型的初始值
		> 2. 代码中出现地址、时间等字符串时需要使用常量代替。
		> 3. 在进行比较的时候吧，尽量使用'=\==', '!=\='代替'==', '!='。  
		> 4. 不要在内置对象的原型上添加方法，如 Array, Date。  
		> 5. switch 语句必须带有 default 分支。  
		> 6. for 循环和 if 语句必须使用大括号。 
4. 如何使用`fetch`函数发送一个GET请求？
	- A：
		```js
		fetch('https://api.example.com/data')
		  .then(response => response.json())
		  .then(data => console.log(data))
		  .catch(error => console.log(error));
		```
	- 解析：`fetch`是一个方法是JS中支持的一种网络请求方法（默认发送post请求），它基于`promise API`因此会返回一个promise对象，因此可以通过`.then()`和`.catch()`方法来处理请求的响应和错误
5. 请解释一下JS中的闭包
	- A：闭包是指函数可以访问其词法作用域外部的变量。当一个函数内部定义了另一个函数，并且在内部函数中引用了外部函数的变量时，就形成了闭包。闭包可以保留外部函数的变量状态，使得外部函数的变量在内部函数执行完后仍然存在。
	- 解析：词法作用域指函数的外层作用域在函数创建时就已经确定了
6. 请解释一下JS中的事件冒泡和事件捕获。
	- A：JS中事件冒泡指的是事件的向上传导，当一个元素上的事件被触发时，它会向父元素传播（父元素上的同类型事件也会被触发），直到传播到文档根节点。
	  事件的捕获与冒泡相反，当一个元素上的事件被触发时，它会从文档根节点开始，逐级向下传播，直到传播到目标元素。
7. 请解释一下JS中的事件委托
	- A：JS中事件委托是一种优化事件处理的方式。事件委托通过将本来绑定给多个元素的事件绑定到公共父元素上，然后利事件冒泡机制来处理子元素的事件。事件委托可以减少事件处理函数的数量，提高页面的性能和可维护性
8. 说说JS中的数据类型？存储上的差别？
	- A：
	  在JS中可以将数据类型分为`基本数据类型`和`复杂数据类型`。
	  
	  - 基本基本数据类型主要有6种（`Number`、`String`、`Boolean`、`Undefined`、`null`和`Symbol`）
	  - 复杂类型统称为Object通常包含以下三种（`Object`、`Array`、`Function`）
	  
	  在存储上基本数据类型存储在栈中，而复杂数据类型存储在堆中（每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中）
9. =\=和===有什么区别？
	- A：对于=\=来说当比较两个变量时，会先判断两个变量的数据类型是否相同若不同，会进行类型转换，若相同直接比较值。===就是比较两个变量在类型和值是否都相等
10. 介绍 js 有哪些内置对象？
	- A：JS中的内置对象主要指的是程序执行前存在全局作用域里的由JS定义的一些全局属性值、函数和实例化其他对象的构造函数对象。一般常用的有全局变量值`NaN`、`undefined`，全局函数如`parseInt()`、`paeseFloat()`，以及用来实例化对象的构造函数如`Data`、`Object`等。
11. null 和 undefined 的区别？
	- A：Undefined和Null都是基本数据类型，两个基本数据类型都分别只有一个值（undefined和null）。

	  undefined代表的含义是未定义而null表示一个空对象，null主要用于赋值给一些可能返回对象的变量，用于初始化。undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

	  当我们对两种类型使用 typeof 进行判断的时候，Null 类型会返回 “object”。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
12. 说说你对作用域链的理解
	- A：
		> 作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合，也可以说作用域决定了代码区块中变量和其他资源的可见性。

		> 作用域链指当我们使用一个变量时，JS解析器会优先在当前作用域中寻找该变量，找到了则使用。若没找到，则依次向上一层中寻找，直到找到然后使用。若一直没找到则会报错显示该变量为定义
13. JavaScript中执行上下文和执行栈是什么？
	- A：
	
		- 简单来说执行上下文是一种对JS代码执行环境的抽象概念，也就是说只要有JS代码运行，那么它一定在执行上下文中
	
			> 执行上下文的类型分为三种：
			>
			> 1. 全局执行上下文：只有一个window对象
			> 2. 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
			> 3. Eval 函数执行上下文： 指的是运行在 `eval` 函数中的代码，不建议使用
			>
			> 执行上下文的生命周期包括创建阶段、执行阶段和回收阶段
			>
			> 1. 创建阶段：函数被调用，但未执行内部代码之前。
			> 2. 执行阶段：执行变量赋值、代码执行
			> 3. 回收阶段：执行上下文出栈等待虚拟机回收执行上下文
	
		- 执行栈，也称为调用栈具有后进先出的特点，用于存储代码在执行期间创建的所有执行上下文。
	
			> 当`Javascript`引擎开始执行你第一行代码的时，它就会创建一个全局执行上下文然后将它压到执行栈中，每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中，当该函数执行结束后，对应的执行上下文就会被弹出，然后执行执行栈中的下一个执行上下文
14. js 的事件循环是什么？
	- A：
		> 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 
	
		>  微任务包括了 promise 的回调、对 Dom 变化监听的 MutationObserver。 
		>
		>  宏任务包括了 script 脚本的执行、setTimeout ，setInterval  一类的定时事件，还有如 I/O 操作等。
15. typeof 与 instanceof 区别 
	- A：
		- typeof：返回一个字符串，表示未经计算的操作数的类型。对于除了null以外的基本数据类型`typeof`可以准确返回其类型（typeof不能作为判断null的方法），对于引用类型数据，用`typeof`来判断的话，除了`function`会被识别出来之外，其余的都输出`object`

			```js
			//可以通过以下方法 判断一个变量是否存在
			if(typeof a != 'undefined'){
			    //变量存在
			}
			```

		- instanceof：用于检测构造函数的`prototype`属性是否出现在某个实例的原型链上。使用方法如下：

			```js
			// object为实例对象  constructor为构造函数
			object instanceof constructor
			
			let car = new String('xxx');
			car instanceof String //true 判断car是否是String对象的实例
			
			let str = 'xxx';
			str instanceof String //false
			```
		
		总结：`typeof`与`instanceof`都是判断数据类型的方法，区别如下。
		
		> 1. typefof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值
		> 2. instanceof  可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型
		> 3. typeof 虽然可以判断基本数据类型（除了null），但是引用数据类型中，除了` function` 类型以外，其他的也无法判断
16. 使用new操作符时发生了什么？
	- A：
		1. 创建一个普通JS对象，称其为新对象
		2. 将构造函数的prototype属性设置为新对象的原型
		3. 执行构造函数，将新对象设置为函数中的this（让函数的this指向新对象）
		4. 根据构造函数返回值类型作判断。若构造函数返回值是一个非原始值，需要正常处理，若返回值是一个原始值或没有指定返回值，则新的对象会作为返回值返回
17. 谈谈 Javascript 中的类型转换机制
	- A：JS中对各类运算符如果运算的类型与预期不符合，就会触发类型转换机制，JS中常见的类型转换有：

		- 显示转换

			> 显示转换是指我们可以清楚的看到类型发生了变化，常见的方法有
			>
			> 1. Number（）：将任意类型的值转化为数值，转换规则如下：
			>
			> 	- 如果字符串是一个合法数字，则会自动转换成对应的数字，如果字符串不是一个合法数字，则转换为NaN。空字符串或纯空格的字符串会转换为数字0
			> 	- 布尔值true转换为数字1，false转换为数字0
			> 	- null转换为数字0，undefined则转换为数字NaN
			>
			> 	如下例：
			>
			> 	```js
			> 	Number('324') // 324  合法字符串
			> 	Number('324abc') // NaN  非法字符串（不可以解析为数值）
			> 	
			> 	// 对象：通常转换成NaN(除了只包含单个数值的数组)
			> 	Number({a: 1}) // NaN
			> 	Number([1, 2, 3]) // NaN
			> 	Number([5]) // 5
			> 	```
			>
			> 2. String（）：可以将任意类型的值转化成字符串
			>
			> 	```js
			> 	String(1) // "1"    数值：转为相应的字符串
			> 	String(true) // "true"    false则转换为'false'
			> 	String(undefined) // "undefined"
			> 	String(null) // "null"
			> 	
			> 	//对象
			> 	String({a: 1}) // "[object Object]"
			> 	String([1, 2, 3]) // "1,2,3"
			> 	```
			>
			> 3. Boolean（）：可以将任意类型的值转为布尔值，转换规则如下：
			>
			> 	- 除了0和NaN以外所有数值类型都为true，0和NaN转换为false
			> 	- 空串转换为false，其他都是true
			> 	- null和undefined都转换为false
			> 	- 任意对象都为true

		- 隐式转换

			> 隐式转换是JS自动对数据进行类型转换，不是我们通过方法来手动转换的。通常在我们进行算术运算和比较运算以及if、while中的条件表达式时会发生自动转换
			>
			> - 当一个任意类型和字符串进行加法运算时，会自动转化为字符串。先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串
			>
			> 	```js
			> 	'5' + 1 // '51'
			> 	'5' + true // "5true"
			> 	'5' + undefined // "5undefined"
			> 	'5' + {} // "5[object Object]"
			> 	'5' + function (){} // "5function (){}"
			> 	
			> 	//因此可以通过为任意类型加一个空串的形式，来将其转换成字符串类型
			> 	true+""   // "true"
			> 	```
			>
			> - 除了加法运算的其他算术运算，会转换为数值
			>
			> - 我们对非数值类型进行正负运算时，会将其转换为数值
			>
			> - 对一个非布尔值进行非操作，他会先将其转换为布尔值再取反
			>
			> - 当对非数字的值进行关系运算时，他会先将其转换为数值然后比较
18. || 和 && 操作符的返回值？
	- A：|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再判断。|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。
		- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
		- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。
19. 同步和异步的区别？
	- A：
		- 同步：同步指的是当一段代码在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
		- 异步：异步指的是当一段代码在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候会继续往下执行，不会阻塞等待消息的返回，当消息返回时再进行处理。
20. 说一说JavaScript中原型，原型链 ? 有什么特点？
	- A：
		- 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值。当我们去访问一个对象的属性时，它不仅会在对象本身还会对象的原型，以及原型的原型上寻找，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾（也就是说某些属性和方法不是存储在实例对象本身中的，而是在Object的构造函数的`prototype`属性上），如下例：
			```js
			function doSomething(){}
			console.log( doSomething.prototype );
			
			//输出如下结果
			{
			    constructor: ƒ doSomething(),
			    __proto__: {
			        constructor: ƒ Object(),
			        hasOwnProperty: ƒ hasOwnProperty(),
			        isPrototypeOf: ƒ isPrototypeOf(),
			        propertyIsEnumerable: ƒ propertyIsEnumerable(),
			        toLocaleString: ƒ toLocaleString(),
			        toString: ƒ toString(),
			        valueOf: ƒ valueOf()
			    }
			}
			```
			可以得出对象内部有一个指针指向（这个指针被称为对象的原型）构造函数的`prototype`属性对应的值（原型对象），原型对象的constructor属性指向该函数。
		- 原型对象也有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，原型链是寻找对象属性的链，原型链的尽头一般来说都是Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。
		
		- 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。
		
		总结：一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象` null`
21. documen.write 和 innerHTML 的区别？
	- A：

		- innerHTML：可以用于获取调用元素的所有子节点对应的HTML内容（包括HTML标签和文本内容），同时可以用于修改指定DOM的元素的内容（可以解析HTML标签），innerHTML是DOM的属性，只会重写页面的某一部分内容。
		- document.write：document.write是直接将内容写入页面的文档流中（整个页面中，且不会解析HTML标签），write是DOM方法，会导致这个页面的重写。

		innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。
22. 什么情况下会发生布尔值的隐式强制类型转换？
	- A：
		1. if (..) 语句中的条件判断表达式。 
		2. for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 
		3. while (..) 和 do..while(..) 循环中的条件判断表达式。 
		4. 三元运算符中的条件判断表达式。
		5. 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
23. == 操作符的强制类型转换规则？
	- A：

		> 1. 符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
		> 2. 其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。  
		> 3. null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。
		> 4.  对象和基本类型的相等比较，对象按顺序调用ToPrimitive、valueof、toString方法将对象转换为，再进行比较。
		> 5. 如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。  
		> 6. 如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
24. ["1", "2", "3"].map(parseInt) 答案是多少？
	- A： [1,NaN,NaN]
	- 解析：

		> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，当val不为字符串时会将其转换为字符串，其中 radix 表示要解析的数字的基数（该值介于 2 ~ 36 之间，如果超出这个范围，将返回 `NaN`。假如 `radix` 未指定或者为 `0`，则为十进制，若以 `0x` 或 `0X` 开头此时假定为十六进制 `16`）。
		>
		> 此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 "1-0", "2-1", "3-2"
		>
		> 第二个值为NaN是因为基数小于了2，第三个值为NaN时因为基数为2表示以二进制显示，而二进制只有0和1因此“3”不满足
25. 介绍一下 js 的节流与防抖？
	- A：
		- 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
		- 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
26.  Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？
	- A：hasOwnProperty。所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。