## JS部分

1. 如何判断一个变量是否为数组？
	- A：可以使用`Array.isArray()`方法来判断一个变量是否为数组。例如：`Array.isArray(myArray)`。
	- 解析：`Array.isArray()`是一个静态方法用于判断一个变量是否为数组。它返回一个布尔值，如果变量是数组则返回`true`，否则返回`false`。
	
2. 如何获取当前日期和时间？
	- A：可以使用`Date`对象来获取当前日期和时间
	- 解析：`Date`对象是JS的内置对象用于处理日期和时间。通过创建一个`Date`对象，可以获取当前日期和时间
	
3. 说几条写 JavaScript 的基本规范？
	- A：
	
		> 1. 一个函数作用域中所有的变量声明应该尽量提到函数首部。声明时如果变量没有值，应该给该变量赋值对应类型的初始值
		> 2. 代码中出现地址、时间等字符串时需要使用常量代替。
		> 3. 在进行比较的时候吧，尽量使用'=\==', '!=\='代替'==', '!='。  
		> 4. 不要在内置对象的原型上添加方法，如 Array, Date。  
		> 5. switch 语句必须带有 default 分支。  
		> 6. for 循环和 if 语句必须使用大括号。 
	
4. 如何使用`fetch`函数发送一个GET请求？
	- A：
		```js
		fetch('https://api.example.com/data')
		  .then(response => response.json())
		  .then(data => console.log(data))
		  .catch(error => console.log(error));
		```
	- 解析：`fetch`是一个方法是JS中支持的一种网络请求方法（默认发送post请求），它基于`promise API`因此会返回一个promise对象，因此可以通过`.then()`和`.catch()`方法来处理请求的响应和错误
	
5. 请解释一下JS中的闭包
	- A：闭包是指函数可以访问其词法作用域外部的变量。当一个函数内部定义了另一个函数，并且在内部函数中引用了外部函数的变量且内部函数执行，就形成了闭包。闭包可以保留外部函数的变量，使得外部函数的变量在内部函数执行完后仍然存在。本质就是外部函数内变量的生命周期因为被内部函数引用而没有被回收
	- 解析：词法作用域指函数的外层作用域在函数创建时就已经确定了，闭包作用就是变量私有化以及延长变量生命周期，闭包使用场景都离不开这俩点（计数器、延迟调用等应用）
	
6. 请解释一下JS中的事件冒泡和事件捕获。
	- A：JS中事件冒泡指的是事件的向上传导，当一个元素上的事件被触发时，它会向父元素传播（父元素上的同类型事件也会被触发），直到传播到文档根节点。
	  事件的捕获与冒泡相反，当一个元素上的事件被触发时，它会从文档根节点开始，逐级向下传播，直到传播到目标元素。
	
7. 请解释一下JS中的事件委托
	- A：JS中事件委托是一种优化事件处理的方式。事件委托通过将本来绑定给多个元素的事件绑定到公共父元素上，然后利事件冒泡机制来处理子元素的事件。事件委托可以减少事件处理函数的数量，提高页面的性能和可维护性
	
8. 说说JS中的数据类型？存储上的差别？
	- A：
	  在JS中可以将数据类型分为`基本数据类型`和`复杂数据类型`。
	  
	  - 基本基本数据类型主要有6种（`Number`、`String`、`Boolean`、`Undefined`、`null`和`Symbol`）
	  - 复杂类型统称为Object通常包含以下三种（`Object`、`Array`、`Function`）
	  
	  在存储上基本数据类型存储在栈中，而复杂数据类型存储在堆中（每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中）
	
9. 什么是堆？什么是栈？它们之间有什么区别和联系？
	- A：堆和栈的概念存在于数据结构中和操作系统内存中。

		> 在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。
		>
		> 在操作系统中，内存被分为栈区和堆区：
		>
		> - 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等
		> - 堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收
	
10. =\=和===有什么区别？
	- A：对于=\=来说当比较两个变量时，会先判断两个变量的数据类型是否相同若不同，会进行类型转换，若相同直接比较值。===就是比较两个变量在类型和值是否都相等
	
11. 介绍 js 有哪些内置对象？
	- A：JS中的内置对象主要指的是程序执行前存在全局作用域里的由JS定义的一些全局属性值、函数和实例化其他对象的构造函数对象。一般常用的有全局变量值`NaN`、`undefined`，全局函数如`parseInt()`、`paeseFloat()`，以及用来实例化对象的构造函数如`Data`、`Object`等。
	
12. null 和 undefined 的区别？
	- A：Undefined和Null都是基本数据类型，两个基本数据类型都分别只有一个值（undefined和null）。

	  undefined代表的含义是未定义而null表示一个空对象，null主要用于赋值给一些可能返回对象的变量，用于初始化。undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。

	  当我们对两种类型使用 typeof 进行判断的时候，Null 类型会返回 “object”。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。
	
13. 说说你对作用域链的理解
	- A：
		> 作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合，也可以说作用域决定了代码区块中变量和其他资源的可见性。

		> 作用域链指当我们使用一个变量时，JS解析器会优先在当前作用域中寻找该变量，找到了则使用。若没找到，则依次向上一层中寻找，直到找到然后使用。若一直没找到则会报错显示该变量为定义
	
14. JavaScript中执行上下文和执行栈是什么？
	- A：
	
		- 简单来说执行上下文是一种对JS代码执行环境的抽象概念，也就是说只要有JS代码运行，那么它一定在执行上下文中
	
			> 执行上下文的类型分为三种：
			>
			> 1. 全局执行上下文：只有一个window对象
			> 2. 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
			> 3. Eval 函数执行上下文： 指的是运行在 `eval` 函数中的代码，不建议使用
			>
			> 执行上下文的生命周期包括创建阶段、执行阶段和回收阶段
			>
			> 1. 创建阶段：创建变量对象，建立作用域链，确定this指向
			> 2. 执行阶段：执行变量赋值、代码执行、函数的引用
			> 3. 回收阶段：执行上下文出栈等待虚拟机回收执行上下文
	
		- 执行栈，也称为调用栈具有后进先出的特点，用于存储代码在执行期间创建的所有执行上下文。
	
			> 当`Javascript`引擎开始执行你第一行代码的时，它就会创建一个全局执行上下文然后将它压到执行栈中，每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中，当该函数执行结束后，对应的执行上下文就会被弹出，然后执行执行栈中的下一个执行上下文
	
15. js 的事件循环是什么？
	- A：
		> 因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，继续执行执行栈中的其他任务。当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。 
	
		>  微任务包括了 promise 的回调、对 Dom 变化监听的 MutationObserver。 
		>
		>  宏任务包括了 script 脚本的执行、setTimeout ，setInterval  一类的定时事件，还有如 I/O 操作等。
	
16. typeof 与 instanceof 区别 
	- A：
		- typeof：返回一个字符串，表示未经计算的操作数的类型。对于除了null以外的基本数据类型`typeof`可以准确返回其类型（typeof不能作为判断null的方法），对于引用类型数据，用`typeof`来判断的话，除了`function`会被识别出来之外，其余的都输出`object`

			```js
			//可以通过以下方法 判断一个变量是否存在
			if(typeof a != 'undefined'){
			    //变量存在
			}
			```

		- instanceof：用于检测构造函数的`prototype`属性是否出现在某个实例的原型链上。使用方法如下：

			```js
			// object为实例对象  constructor为构造函数
			object instanceof constructor
			
			let car = new String('xxx');
			car instanceof String //true 判断car是否是String对象的实例
			
			let str = 'xxx';
			str instanceof String //false
			```
		
		总结：`typeof`与`instanceof`都是判断数据类型的方法，区别如下。
		
		> 1. typefof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值
		> 2. instanceof  可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型
		> 3. typeof 虽然可以判断基本数据类型（除了null），但是引用数据类型中，除了` function` 类型以外，其他的也无法判断
	
17. 使用new操作符时发生了什么？
	- A：
		1. 创建一个普通JS对象，称其为新对象
		2. 将构造函数的prototype属性设置为新对象的原型
		3. 执行构造函数，将新对象设置为函数中的this（让函数的this指向新对象）
		4. 根据构造函数返回值类型作判断。若构造函数返回值是一个非原始值，需要正常处理，若返回值是一个原始值或没有指定返回值，则新的对象会作为返回值返回
	
18. 谈谈 Javascript 中的类型转换机制
	- A：JS中对各类运算符如果运算的类型与预期不符合，就会触发类型转换机制，JS中常见的类型转换有：

		- 显示转换

		  > 显示转换是指我们可以清楚的看到类型发生了变化，常见的方法有
		  >
		  > 1. Number（）：将任意类型的值转化为数值，转换规则如下：
		  >
		  >   - 如果字符串是一个合法数字，则会自动转换成对应的数字，如果字符串不是一个合法数字，则转换为NaN。空字符串或纯空格的字符串会转换为数字0
		  >   - 布尔值true转换为数字1，false转换为数字0
		  >   - null转换为数字0，undefined则转换为数字NaN
		  >
		  >   如下例：
		  >
		  >   ```js
		  >   Number('324') // 324  合法字符串
		  >   Number('324abc') // NaN  非法字符串（不可以解析为数值）
		  >   
		  >   // 对象：通常转换成NaN(除了只包含单个数值的数组)
		  >   Number({a: 1}) // NaN
		  >   Number([1, 2, 3]) // NaN
		  >   Number([5]) // 5
		  >   Number([])  // 0
		  >   ```
		  >
		  > 2. String（）：可以将任意类型的值转化成字符串
		  >
		  >   ```js
		  >   String(1) // "1"    数值：转为相应的字符串
		  >   String(true) // "true"    false则转换为'false'
		  >   String(undefined) // "undefined"
		  >   String(null) // "null"
		  >   
		  >   //对象
		  >   String({a: 1}) // "[object Object]"
		  >   String([1, 2, 3]) // "1,2,3"
		  >   String([])  // ''
		  >   ```
		  >
		  > 3. Boolean（）：可以将任意类型的值转为布尔值，转换规则如下：
		  >
		  > 	- 除了0和NaN以外所有数值类型都为true，0和NaN转换为false
		  > 	- 空串转换为false，其他都是true
		  > 	- null和undefined都转换为false
		  > 	- 任意对象都为true

		- 隐式转换
		
			> 隐式转换是JS自动对数据进行类型转换，不是我们通过方法来手动转换的。通常在我们进行算术运算和比较运算以及if、while中的条件表达式时会发生自动转换
			>
			> - 当一个任意类型和字符串进行加法运算时，会自动转化为字符串。先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串
			>
			> 	```js
			> 	'5' + 1 // '51'
			> 	'5' + true // "5true"
			> 	'5' + undefined // "5undefined"
			> 	'5' + {} // "5[object Object]"
			> 	'5' + function (){} // "5function (){}"
			> 	
			> 	//因此可以通过为任意类型加一个空串的形式，来将其转换成字符串类型
			> 	true+""   // "true"
			> 	```
			>
			> - 除了加法运算的其他算术运算，会转换为数值
			>
			> - 我们对非数值类型进行正负运算时，会将其转换为数值
			>
			> - 对一个非布尔值进行非操作，他会先将其转换为布尔值再取反
			>
			> - 当对非数字的值进行关系运算时，他会先将其转换为数值然后比较
	
19. || 和 && 操作符的返回值？
	- A：|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再判断。|| 和 && 返回它们其中一个操作数的值，而非条件判断的结果。
		- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。
		- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。
	
20. 下面题目输出的结果
	```js
	var val = "test";
	console.log("output is " + (val === "Test") ? "123" : "456");
	```

	- A：输出‘123’
	- 解析：本质是一个运算符优先级问题，在针对该题来说 `()` > `+` > `?`按照这种优先级来处理。所以先对`val==='Test'`判断（false）再进行字符串加法运算（结果为‘out put is false’），在进行三目运算而`‘out put is false’`为true所以输出123
	
21. 同步和异步的区别？
	- A：
		- 同步：同步指的是当一段代码在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。
		- 异步：异步指的是当一段代码在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候会继续往下执行，不会阻塞等待消息的返回，当消息返回时再进行处理。
	
22. 说一说JavaScript中原型，原型链 ? 有什么特点？
	- A：
		- 在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值。当我们去访问一个对象的属性时，它不仅会在对象本身还会对象的原型，以及原型的原型上寻找，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾（也就是说某些属性和方法不是存储在实例对象本身中的，而是在Object的构造函数的`prototype`属性上），如下例：
			```js
			function doSomething(){}
			console.log( doSomething.prototype );
			
			//输出如下结果
			{
			    constructor: ƒ doSomething(),
			    __proto__: {
			        constructor: ƒ Object(),
			        hasOwnProperty: ƒ hasOwnProperty(),
			        isPrototypeOf: ƒ isPrototypeOf(),
			        propertyIsEnumerable: ƒ propertyIsEnumerable(),
			        toLocaleString: ƒ toLocaleString(),
			        toString: ƒ toString(),
			        valueOf: ƒ valueOf()
			    }
			}
			```
			可以得出对象内部有一个指针指向（这个指针被称为对象的原型）构造函数的`prototype`属性对应的值（原型对象），原型对象的constructor属性指向该函数。
		- 原型对象也有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，原型链是寻找对象属性的链，原型链的尽头一般来说都是Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。
		
		- 特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。
		
		总结：一切对象都是继承自`Object`对象，`Object` 对象直接继承根源对象` null`
	
23. documen.write 和 innerHTML 的区别？
	- A：

		- innerHTML：可以用于获取调用元素的所有子节点对应的HTML内容（包括HTML标签和文本内容），同时可以用于修改指定DOM的元素的内容（可以解析包含HTML的给定内容），innerHTML是DOM的属性，只会重写页面的某一部分内容。
		- document.write：document.write是直接将内容写入页面的文档流中（整个页面中，导致整个页面重写），会自动调用open方法（）开启一个新的文档流，write是DOM方法，会导致这个页面的重写。

		innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。
	
24. 什么情况下会发生布尔值的隐式强制类型转换？
	- A：
		1. if (..) 语句中的条件判断表达式。 
		2. for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 
		3. while (..) 和 do..while(..) 循环中的条件判断表达式。 
		4. 三元运算符中的条件判断表达式。
		5. 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
	
25. == 操作符的强制类型转换规则？
	- A：
	
		> 1. 字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。
		> 2. 其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。  
		> 3. null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。
		> 4.  对象和基本类型的相等比较，对象按顺序调用ToPrimitive、valueof、toString方法将对象转换为基本类型，再进行比较。
		> 5. 如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。  
		> 6. 如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
	
26. ["1", "2", "3"].map(parseInt) 答案是多少？
	- A： [1,NaN,NaN]
	- 解析：

		> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，当val不为字符串时会将其转换为字符串，其中 radix 表示要解析的数字的基数（该值介于 2 ~ 36 之间，如果超出这个范围，将返回 `NaN`。假如 `radix` 未指定或者为 `0`，则为十进制，若以 `0x` 或 `0X` 开头此时假定为十六进制 `16`）。
		>
		> 此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 "1-0", "2-1", "3-2"
		>
		> 第二个值为NaN是因为基数小于了2，第三个值为NaN时因为基数为2表示以二进制显示，而二进制只有0和1因此“3”不满足
	
27. 介绍一下 js 的节流与防抖？
	- A：
		- 函数防抖是指在事件被触发 n 秒后才执行回调，如果在这 n 秒内事件又被触发，则重新计时（将多次触发变为只执行最后一次）。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
		- 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行（节流是将多次执行变为每隔一段时间执行一次），如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。
	
28.  Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？
	- A：hasOwnProperty。所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
	
29. undefined 与 undeclared 的区别？
	- A：已在作用域中声明但还没有赋值的变量是undefined，在作用域中没有声明的变量是undeclared。

		> 对于undeclared变量的使用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用typeof的安全防范机制来避免报错，因为对于undeclared（或者not defined ）变量，typeof 会返回"undefined"。
	
30.  js 获取原型的方法？
	- A：
		- p._\_proto_\_：通过对象._\_proto_\_ 来访问对象的原型对象，这是一个隐含的属性，所以并不推荐。
		- p.constructor.prototype
		- Object.getPrototypeOf(p)
	
31. typeof NaN 的结果是什么？
	- A：会返回number
	- 解析：NaN意指不是一个数字（not a number），NaN 是一个sentinel value（有特殊用途的常规值）也称为警戒值，用于指出数字类型中的错误情况。NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值，NaN != NaN 为 true。
	
32. isNaN 和 Number.isNaN 函数的区别？
	- A：

		> - isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也可能会返回 true ，会影响 NaN 的判断。
		> - Number.isNaN会首先判断传入参数是否为数字，如果是数字再继续判断是否为NaN，这种方法对于 NaN 的判断更为准确。
	
33. Array构造函数只有一个参数值时的表现？
	- A：Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样 创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。
	
34. 什么是假值对象？
	- A：浏览器在某些特性的情况下，在常规JS语法基础上自己创建的一些外来值，称为假值对象。假值对象看起来和普通对象没有区别，但将它们强制类型转换为布尔值时结果为false 最常见的例子是document.all，它是一个类数组对象，包含了页面上的所有元素，由DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。
	
35. eval 是做什么的？
	- A：它的功能是把对应的字符串解析成 JS 代码并运行，返回字符串中代码的返回值。如果 eval()的参数不是字符串， eval()会将参数原封不动地返回

		> 应该避免使用 eval，它一个危险的函数不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。
	
36. Object.is() 与原来的比较操作符 =\==、=\=”的区别？

	- A：Object.is()是一个静态方法，也用于判断两个值是否相等

		> Object.is()的比较规则类似于==\=，不会进行类型转换（而=\=会进行强制类型转换），与\=\==的区别是在Object.is()中它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个NaN 认定为是相等的。
		>
		> Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。
	
37. 谈谈this对象的理解
	- A：在绝大多数情况下，函数的调用方式决定了this的指向，this是函数的一个内部对象，只能在函数内部使用，指向最后一次调用这个方法的对象。this对象的绑定发生在函数调用的时候而不是定义的时候，this的指向可以通过四种调用模式来判断

		> 1. 函数调用模式：当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。若在严格模式中 this会绑定到undefined
		>
		> 	```js
		> 	var name = 'Jenny';
		> 	function person() {
		> 	    return this.name;
		> 	}
		> 	console.log(person());  //Jenny
		> 	```
		>
		> 2. 方法调用模式：当一个函数作为对象中一个方法被调用时，this 指向这个对象
		>
		> 	```js
		> 	//这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象
		> 	var o = {
		> 	    a:10,
		> 	    b:{
		> 	        fn:function(){
		> 	            console.log(this.a); //undefined
		> 	        }
		> 	    }
		> 	}
		> 	o.b.fn();
		> 	```
		>
		> 3. 构造器调用模式：如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。再看一个特殊情况：
		>
		> 	```js
		> 	//new过程遇到return一个对象，此时this指向返回的对象
		> 	function fn()  
		> 	{  
		> 	   this.user = 'xxx';  
		> 	   return {};  
		> 	}
		> 	var a = new fn();  
		> 	console.log(a.user); //undefined
		> 	
		> 	//若返回一个简单类型或null时，this仍然指向实例对象
		> 	```
		>
		> 4. call、bind、apply调用模式：他们都是函数的方法可以用于指定函数调用时的this指向，第一个参数就表示改变后的调用这个函数的this
		>
		> 	```js
		> 	var person = {
		> 	    name: ""
		> 	};
		> 	setName.call(person,"xiao","ming");
		> 	console.log(person.name); // "xiao ming" 
		> 	function setName(firstName,lastName){
		> 	    this.name = firstName + lastName; //此时this指的是person对象
		> 	}
		> 	```
		>
		> 这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后 是函数调用模式。
	
38. 说说JavaScript中的事件模型
	- A：在JS中事件模型分为三种

		- 原始事件模型（DOM0级别），兼容所有浏览器（绑定速度快），在这种模型下绑定事件只支持冒泡，不支持捕获，且同一个类型的事件只能绑定一次。

			```js
			//通过JS来绑定事件
			var btn = document.getElementById('#btn');
			btn.onclick=fun;
			```

			```html
			<!-- 在html中直接绑定事件 -->
			<input type="button" onclick="fun()">
			```

		- 标准事件模型（DOM2级别），这种事件模型一次事件共有三个过程，事件绑定是通过addEventListener函数来绑定的（可以为一个节点绑定多个事件处理器，且各自不冲突），其中第三个参数可以指定事件是否在捕获阶段执行

			```js
			var btn = document.getElementById('#btn');
			//第三个参数用于指定是否在捕获阶段进行处理,不添加默认为false
			btn.addEventListener('click', fn(), boolean);
			```

		- IE事件模型（基本不会使用），该事件模型的事件有两个过程：目标阶段和冒泡阶段

	- 解析：JS的事件可以理解为在HTML文档或者浏览器中发生的一种交互操作，使网页具备互动性。而DOM是一个树形结构，如果在父子节点同时绑定事件时，当触发子节点的事件时，就存在一个顺序问题，这就涉及到了事件流的概念。事件流包括三个阶段：捕获阶段、目标阶段、冒泡阶段。
	
39. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？
	- A：解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。
	- 解析：解析允许字符串是指以将字符串解析为其他数据类型或执行特定的操作（如parseInt()、parseFloat()、JSON.parse()等）
	
40. JavaScript 类数组对象的定义？
	- A：一个拥有length属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有arguments和DOM方法的返回结果（如querySelectorAll()获取的节点列表），还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。
	
		> 可以通过如下方法将类数组对象转换为数组：
		>
		> 1. 通过 call 调用数组的 slice 方法来实现转换
		> 2. 通过 call 调用数组的 splice 方法来实现转换
		> 3. 通过过 apply 调用数组的 concat 方法来实现转换
		> 4. 通过Array.from来转换
	
41. {} 和 [] 的 valueOf 和 toString 的结果是什么？
	- A：

		> {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"  
		>
		> [] 的 valueOf 结果为 [] ，toString 的结果为 ""

	- 解析：

		> 通常vlueOf和toString在一些运算符操作时被自动调用（隐式转换）
		>
		> - valueOf：返回当前对象的原始值（除了Date对象会被转换为时间戳），其他任意类型返回对象本身
		> - toString：返回一个表示该对象的字符串，除了null和undefined以外其他类型均可调用该方法，对于一个Object来说调用该方法返回`"[object Object]"`，数组调用该方法返回以逗号分隔的字符串。
		> - Symbol.toPrimitive：是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。它的优先级最高
		>
		> valueOf()偏向于运算，toString()偏向于显示。在有运算符操作的情况下valueOf()的优先级高于toString()
	
42. mouseover 和 mouseenter 的区别？
	- A：当鼠标移动到元素上时就会触发mouseenter事件，在功能上类似mouseove，它们两者之间的差别是mouseenter不具备事件冒泡的特性。由于mouseenter不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。
	
43. Javscript数组的常用方法有哪些？

	- A：

		- 增

			> 下面的前两种方法是破坏性的会改变原数组
			>
			> push()：该方法接收任意数量的参数，并将他们添加到数组的末尾，并返回新数组的长度
			>
			> unshift()：在数组开头添加任意多个值，然后返回新的数组长度
			>
			> concat()：用于合并两个或多个数组，并返回新的合并后的数组，不会修改原始数组

		- 删

			> 两种方法都会改变原数组
			> pop()：删除数组中最后一个元素，并返回删除的元素
			>
			> shift()：删除数组中第一个元素，返回被删除的元素

		- 两个特殊方法

			> slice()：用于截取数组，并返回一个新数组，有两个参数第一个参数表示截取开始位置，第二个表示结束位置（截取结果不包括），也可以用于删除数组中元素
			>
			> ```js
			> var b=[1,456,185,25,1,5];
			> var ee =b.slice(0,2)  // [1,456]
			> //当第二个参数省略 则默认到数组末尾元素
			> var c = b.slice(3); // [25,1,5]
			> ```
			>
			> splice()：可以用于添加、删除、修改数组，会破坏原数组。
			>
			> ```js
			> //当只有两个参数时表示删除元素，第一个参数表示要删除的位置，第二个参数表示删除个数，返回删除的元素
			> let colors = ["red", "green", "blue"];
			> colors.splice(0,1);
			> console.log(colors); // green,blue
			> //添加时第一个参数指定添加位置，第二个参数为0，第三个参数为要插入的元素，此时返回一个空数组
			> let colors = ["red", "green", "blue"];
			> let removed = colors.splice(1, 0, "yellow", "orange")
			> console.log(colors) // red,yellow,orange,green,blue
			> console.log(removed) // []
			> //替换时只需将第二个参数改为1即可，第三个参数表示要替换的元素，返回被替换的元素
			> let colors = ["red", "green", "blue"];
			> let removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素
			> console.log(colors); // red,red,purple,blue
			> ```

		- 查找

			> - indexOf()：返回要查找元素在数组中的下标，若不存在则返回-1
			> - includes()：检查数组是否包含指定元素，返回一个布尔值
			> - find()：需要一个函数作为参数，返回数组中符合函数中规定的元素，是一个迭代方法

		- 其他方法

			> - reverse()：将数组反转，改变原数组
			> - sort()：对数组进行排序，默认升序，可以通过指定一个函数作为参数来改变排序规则，改变原数组
			> 	- join()：将数组中的元素拼接为字符串，默认每个元素用逗号连接，可以传递一个字符串作为参数来作为连接符
			> - 以及一些迭代方法some()、every()、forEach()、filter()、map()
	
44. ajax原理是什么？如何实现？

	- A：AJAX全称Async Javascript and XML表示异步的JavaScript和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下（不用刷新网页），与服务器交互数据，并更新页面中部分内容。

		> 实现过程：
		>
		> - 创建Ajax的核心对象XMLHttpRequest对象
		>
		> 	```js
		> 	const xhr = new XMLHttpRequest();
		> 	```
		>
		> - 通过 `XMLHttpRequest` 对象的 `open()` 方法与服务端建立连接
		>
		> - 构建请求所需的数据内容，并通过` XMLHttpRequest` 对象的 `send()` 方法发送给服务器端
		>
		> 	```js
		> 	xhr.send([body]);
		> 	//body表示发送的请求体数据，若不传递默认为null
		> 	//当发送请求的方法为GET时，要将请求数据添加到open()方法中的url地址中。发送请求数据中的send()方法中参数设置为null
		> 	```
		>
		> - 通过`onreadystatechange` 事件监听服务器端你的通信状态，他会监听实例对象的readyState属性的状态，每次状态改变都会触发事件
		>
		> 	> 主要有五个状态码：
		> 	>
		> 	> 1. 0表示open方法未被调用
		> 	> 2. 1表示send方法未被调用
		> 	> 3. 2表示send方法调用，响应头和状态码返回
		> 	> 4. 3表示获取响应的数据体
		> 	> 5. 表示整个请求完成数据以接收，或本次接收失败
		>
		> - 接受并处理服务端向客户端响应的结果，通过`responseText`属性接收服务器端的响应结果
		>
		> - 将响应的数据或结果更新到页面中
		>
		> ```js
		> const request = new XMLHttpRequest()
		> request.onreadystatechange = function(){
		>     if(request.readyState === 4){ // 整个请求过程完毕
		>         if(request.status >= 200 && request.status <= 300){
		>             console.log(request.responseText) // 服务端返回的结果
		>         }else if(request.status >=400){
		>             console.log("错误信息：" + request.status)
		>         }
		>     }
		> }
		> request.open('POST','http://xxxx')
		> request.send()
		> ```
	
45. js函数有哪几种声明方式？有什么区别？

	- A：函数声明分为表达式和声明式

		- 函数的声明式写法为：`function test(){}`，这种写法会导致函数提升，所有通过`function`关键字声明的变量都会被解释器优先编译，但是它本身并不会被执行。
		- 函数的表达式写法为：`var test = function(){}`，这种写法不会导致函数提升，必须先声明后调用，不然就会报错

		> 区别：
		>
		> 1. 声明式创建的函数会发生提升现象，而表达式不会
		> 2. 函数声明中的函数名是必需的，而函数表达式中的函数名则是可选的
		> 3. 函数表达式可以在定义的时候直接在表达式后面加()执行，而函数声明则不可以
		>
		> WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏

